#Gonna go for small-medium company CI/CD.
#This will have 10 steps.
#Uses: calls a prebuilt action (like checkout or setup-node)
#run: executes a shell command inside the VM.

#Phase 1
name: mid1CI/CD

on:
  push:
    branches: main

#Phase 2
jobs:
  build:
    runs-on: ubuntu-latest

#Why do we separate on: and runs-on:? Because they run on different layers of abstractions. On says when to do it, and runs-on is where aka the environment and fits the logical flow of a developers actions.
#Analogy:
# on = When the event happens -->  party starts when client confirms guest list.
#Runs-on = where the event takes place --> Picking the venue/environment its allowed but doesnt decide when the party starts.
#Steps = What happens during the events --> Specific actions inside venue such as catering, dance and speeches when party has started.

#Phase3 (steps)
#VM starts empty, no code, no files. You need your project files to be available before you can install dependencies, run tests, or build.
#GitHub provides prebuilt action for this so we don't have to write shell scripts.

steps:
#step 1. Checkout code --> Gives you files
  - name: Checkout repository #always first actions, bc everything else depends on code being there.
    uses: actions/checkout@v3 #This over git clone auto checks correct commit/branch, handles submodules and history c orreclty, keeps workflow simple, supports cashing and shallow clone optimizations.

#step 2. setup environment --> Gives you the runtime/interpreter your code needs.
  - name: Setup Node.Js
    uses: actions/setup-node@v3
    with:
      node-version: '20'

#step 3. install dependencies - now you can install safely as environment exists.
  - name: Install dependencies
    run: npm install 