#Gonna go for small-medium company CI/CD.
#This will have 10 steps.
#Uses: calls a prebuilt action (like checkout or setup-node), uses is used for infra/tooling setup (checkout, runtime, auth, caching)
#run: executes a shell command inside the VM. Run is used for project-specific logic such as tests,builds,scripts)

#Phase 1
name: mid1CI/CD

on:
  push:
    branches: main

#Phase 2
jobs:
  build:
    runs-on: ubuntu-latest

#Why do we separate on: and runs-on:? Because they run on different layers of abstractions. On says when to do it, and runs-on is where aka the environment and fits the logical flow of a developers actions.
#Analogy:
# on = When the event happens -->  party starts when client confirms guest list.
#Runs-on = where the event takes place --> Picking the venue/environment its allowed but doesnt decide when the party starts.
#Steps = What happens during the events --> Specific actions inside venue such as catering, dance and speeches when party has started.

#Phase3 (steps)
#VM starts empty, no code, no files. You need your project files to be available before you can install dependencies, run tests, or build.
#GitHub provides prebuilt action for this so we don't have to write shell scripts.

steps:
#step 1. Checkout code --> Gives you files
  - name: Checkout repository #always first actions, bc everything else depends on code being there.
    uses: actions/checkout@v3 #This over git clone auto checks correct commit/branch, handles submodules and history c orreclty, keeps workflow simple, supports cashing and shallow clone optimizations.

#step 2. setup environment --> Gives you the runtime/interpreter your code needs.
  - name: Setup Node.Js
    uses: actions/setup-node@v3
    with:
      node-version: '20'

#step 3. install dependencies - now you can install safely as environment exists.
  - name: Install dependencies
    run: npm install 

#step 4. Run tests - We run tests after dependencies as code depends on libraries and modules, and we test before the build for early error detection to save time and avoid shipping broken code.

#step 5 - Build Project - We separate actual artifact creation which is step 5 (deployable artifact = bundle, compiled files, docker imagese etc)
  - name: Build project
    run: npm run build

#step 6. Security checks - We can dependencies or code for vulneabilities before deployment.
  - name: Security checks
    run: npm audit --audit-level=high

    #npm audit scans your project dependencies for known vulnerabilities.
    #--audit-level=high ensures only critical/high vulnerabilities fail the workflow.
    # By keeping it after build, you check the actual code you're playing deploying, including all installed dependencies
    #Security checks are run after dependencies but before deployment bc dependencies are on attack surface, they catch vuln before deployment and fail-fast principle.
    #Each step d oes one thing well, making debugging and maintenance easier.


#step 7. Deployment. #Now we go from CI to CD .

  - name: Deploy to GitHub Pages
    uses: peaceiris/actions-gh-pages@v4
    with:
      github_token: ${{secrets.github_token }}
      publish_dir: ./build

#use a prebuilt action like uses for deployment bc it handles authentication, branch switching and commit safely.
#Deployment only happens if prev step passes --> Ensures only tested, secure code is shipped.
#Secrets stored in Github --> Avoids exposing tokens in the workflow.
#Modular design --> can later replace github pages with AWS, docker deploy etc without touching early steps.

#step 8. Notifications.

  - name: Notify via slack
    if: always() #run on success or failure
    uses: slackapi/slack-github-action@v1.23.0
    with:
      channel-id: 'YOUR_CHANNEL_ID'
      slack-token: ${{secrets.SLACK_TOKEN}}
      text: 'Deployment finshed! Check the status.'

      #if: always() --> Ensures notif runs even if prev step fails.
      #prebuilt action(uses:) --> Handles slack api integration, auth, formatting
      #secrets --> Slack token is stored securely in github secrets, never hard-coded.
      #Modular -> You can swap Slack for Teams, email or even a custom webhook without touching the rest of the pipeline.
      